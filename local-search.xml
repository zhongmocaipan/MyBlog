<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ucore_lab1</title>
    <link href="/2024/09/22/ucore-lab1/"/>
    <url>/2024/09/22/ucore-lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="练习1：理解内核启动中的程序入口操作"><a href="#练习1：理解内核启动中的程序入口操作" class="headerlink" title="练习1：理解内核启动中的程序入口操作"></a>练习1：理解内核启动中的程序入口操作</h2><h3 id="la-sp-bootstacktop"><a href="#la-sp-bootstacktop" class="headerlink" title="la sp, bootstacktop"></a><strong>la sp, bootstacktop</strong></h3><p>这条指令将栈指针 <code>sp</code> 初始化为内核栈顶 <code>bootstacktop</code>。其目的是为内核的初始化阶段设置一个安全的栈空间，以便后续执行函数调用时有足够的栈空间。</p><h3 id="tail-kern-init"><a href="#tail-kern-init" class="headerlink" title="tail kern_init"></a><strong>tail kern_init</strong></h3><p><code>tail kern_init</code> 的作用是跳转到 <code>kern_init</code> 函数执行，同时它是一个尾调用优化形式，意味着它在执行过程中不会保留当前函数的返回地址，而是直接跳转到 <code>kern_init</code>，从而节省栈空间。</p><h3 id="关键知识点："><a href="#关键知识点：" class="headerlink" title="关键知识点："></a>关键知识点：</h3><ul><li>栈指针 <code>sp</code> 的初始化是为了确保内核在执行时有一个栈供其使用。</li><li><code>tail</code> 调用可以优化跳转操作，减少不必要的栈操作。</li></ul><hr><h2 id="练习2：完善中断处理"><a href="#练习2：完善中断处理" class="headerlink" title="练习2：完善中断处理"></a>练习2：完善中断处理</h2><h3 id="实现-trap-c-中时钟中断处理"><a href="#实现-trap-c-中时钟中断处理" class="headerlink" title="实现 trap.c 中时钟中断处理"></a>实现 <code>trap.c</code> 中时钟中断处理</h3><ol><li>首先在中断处理函数中，调用 <code>clock_set_next_event()</code> 设置下次时钟中断。</li><li>每次时钟中断时，计数器 <code>ticks</code> 递增。当 <code>ticks</code> 达到 100 时，调用 <code>print_ticks()</code> 输出 “100 ticks”。</li><li>每次输出 100 ticks 后，计数器 <code>num</code> 递增，判断是否已经打印了 10 次，如果是，则调用 <code>sbi.h</code> 中的 <code>shutdown()</code> 函数关机。</li></ol><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><img src="/image/report/1726979027919.png" alt="1726979027919"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exception_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (tf-&gt;cause) &#123;<br>        <span class="hljs-keyword">case</span> CAUSE_MISALIGNED_FETCH:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_FAULT_FETCH:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_ILLEGAL_INSTRUCTION:<br>            <span class="hljs-comment">/* LAB1 CHALLENGE3: 非法指令异常处理 */</span><br>            cprintf(<span class="hljs-string">&quot;Illegal instruction at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            tf-&gt;epc += <span class="hljs-number">4</span>; <span class="hljs-comment">// 跳过非法指令</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_BREAKPOINT:<br>            <span class="hljs-comment">/* LAB1 CHALLENGE3: 断点异常处理 */</span><br>            cprintf(<span class="hljs-string">&quot;Breakpoint at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            tf-&gt;epc += <span class="hljs-number">4</span>; <span class="hljs-comment">// 跳过断点指令</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_MISALIGNED_LOAD:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_FAULT_LOAD:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_MISALIGNED_STORE:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_FAULT_STORE:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_USER_ECALL:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_SUPERVISOR_ECALL:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_HYPERVISOR_ECALL:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_MACHINE_ECALL:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            print_trapframe(tf);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="关键知识点：-1"><a href="#关键知识点：-1" class="headerlink" title="关键知识点："></a>关键知识点：</h3><ul><li>时钟中断的处理：每次时钟中断触发后，需要设置下次时钟事件。</li><li>通过计数器控制定时输出，并实现最终的关机操作。</li></ul><hr><h2 id="Challenge-1：中断处理流程"><a href="#Challenge-1：中断处理流程" class="headerlink" title="Challenge 1：中断处理流程"></a>Challenge 1：中断处理流程</h2><h3 id="mov-a0-sp-的目的"><a href="#mov-a0-sp-的目的" class="headerlink" title="mov a0, sp 的目的"></a>mov a0, sp 的目的</h3><p>该指令将当前栈指针 <code>sp</code> 的值保存到寄存器 <code>a0</code> 中，目的是将栈指针传递给异常处理函数，以便处理函数可以访问保存的寄存器状态。</p><p>在 <code>__alltraps</code> 中的 <code>mov a0, sp</code> 是将栈指针寄存器 <code>sp</code> 的值移动到寄存器 <code>a0</code> 中。其目的是为了将当前内核栈的栈顶指针传递给 C 语言函数 <code>trap()</code>，从而让 <code>trap()</code> 函数能够使用该栈指针来访问保存的寄存器状态和其他上下文信息。这样可以确保 C 语言的异常处理函数能够正确处理和访问保存的 CPU 状态。</p><h3 id="SAVE-ALL-中寄存器保存在栈中的位置确定"><a href="#SAVE-ALL-中寄存器保存在栈中的位置确定" class="headerlink" title="SAVE_ALL 中寄存器保存在栈中的位置确定"></a>SAVE_ALL 中寄存器保存在栈中的位置确定</h3><p>寄存器保存的位置根据 <code>sp</code> 的当前值向下偏移依次存储。每个寄存器对应的栈位置通过特定的偏移量来访问。</p><h3 id="alltraps-中是否需要保存所有寄存器"><a href="#alltraps-中是否需要保存所有寄存器" class="headerlink" title="__alltraps 中是否需要保存所有寄存器"></a>__alltraps 中是否需要保存所有寄存器</h3><p>是的。在中断发生时，需要保存所有寄存器，以确保中断处理完成后能够正确恢复被打断的进程的状态。这是因为中断可能会打断任意时刻的执行，因此需要保留所有的寄存器信息。</p><h3 id="1-ucore处理中断异常的流程"><a href="#1-ucore处理中断异常的流程" class="headerlink" title="1. ucore处理中断异常的流程"></a>1. <strong>ucore处理中断异常的流程</strong></h3><p>   在 RISC-V 中，当 CPU 遇到中断或异常时，系统会自动跳转到预先设置好的中断向量表中定义的中断处理程序。在 uCore 操作系统中，处理中断异常的流程如下：</p><ul><li><p><strong>异常发生</strong>：</p><ul><li>CPU 遇到一个中断或异常。</li><li>当前执行流的状态（包括寄存器、程序计数器等）需要保存下来，以便处理完异常后能够恢复正常执行。</li></ul></li><li><p><strong>切换到异常处理代码</strong>：</p><ul><li>RISC-V 的 <code>stvec</code> 寄存器指向的地址保存了异常处理程序的入口地址。在 <code>idt_init()</code> 函数中，<code>stvec</code> 被设置为 <code>__alltraps</code>，该函数是中断&#x2F;异常的统一入口。</li></ul></li><li><p>**进入 <code>__alltraps</code>**：</p><ul><li><code>__alltraps</code> 是汇编实现的入口函数，负责保存当前的 CPU 状态（包括所有寄存器）到栈中，以便后续的 C 语言代码能够使用这些寄存器，并处理中断或异常。</li></ul></li><li><p><strong>保存寄存器状态</strong>：</p><ul><li><code>__alltraps</code> 会调用 <code>SAVE_ALL</code> 宏，将当前的所有寄存器保存到栈上。保存状态的顺序是预先定义好的，通常是按照 RISC-V 的寄存器 ABI 规范。</li></ul></li><li><p><strong>切换到内核栈</strong>：</p><ul><li>在 <code>SAVE_ALL</code> 中的 <code>mov a0, sp</code>，将栈指针寄存器 <code>sp</code> 的值传递给 <code>a0</code>，这是为了将当前的栈指针传递给内核的 C 语言中断处理函数，以便后续的中断处理函数能够访问保存的寄存器信息。</li></ul></li><li><p>**进入 <code>trap()</code>**：</p><ul><li>中断处理程序会调用 <code>trap()</code> 函数，<code>trap()</code> 根据 <code>cause</code> 寄存器的值来判断中断或异常的类型，然后分发给具体的中断处理函数或者异常处理函数。</li></ul></li><li><p><strong>处理完中断后恢复寄存器</strong>：</p><ul><li>中断处理结束后，控制权返回到 <code>__alltraps</code>，从栈中恢复所有保存的寄存器状态，最后返回到被中断的程序位置，继续执行未完成的任务。</li></ul></li></ul><hr><h3 id="3-SAVE-ALL-中寄存器保存在栈中的位置是如何确定的？"><a href="#3-SAVE-ALL-中寄存器保存在栈中的位置是如何确定的？" class="headerlink" title="3. SAVE_ALL 中寄存器保存在栈中的位置是如何确定的？"></a>3. <strong><code>SAVE_ALL</code> 中寄存器保存在栈中的位置是如何确定的？</strong></h3><p>   在 <code>SAVE_ALL</code> 宏中，寄存器保存的顺序是由 RISC-V 的 ABI（应用二进制接口）和系统架构规范决定的。通常寄存器会按固定顺序保存在栈中，这个顺序通常为：</p><ol><li><p>临时寄存器 (<code>t0</code>, <code>t1</code>, <code>t2</code>, …)。</p></li><li><p>返回地址 (<code>ra</code>)。</p></li><li><p>全局指针 (<code>gp</code>)、线程指针 (<code>tp</code>)。</p></li><li><p>保存寄存器 (<code>s0</code>, <code>s1</code>, …, <code>s11</code>)。</p></li><li><p>参数寄存器 (<code>a0</code>, <code>a1</code>, …, <code>a7</code>)。</p><p>在 RISC-V 中，寄存器按照 ABI 规范进行调用约定，某些寄存器如 <code>a0</code> 到 <code>a7</code> 用于传递参数，<code>t0</code> 到 <code>t6</code> 是临时寄存器，而 <code>s0</code> 到 <code>s11</code> 是保存寄存器。寄存器的保存位置按照这些规则顺序决定，方便在中断返回时按正确顺序恢复。</p></li></ol><hr><h3 id="4-对于任何中断，-alltraps-中都需要保存所有寄存器吗？"><a href="#4-对于任何中断，-alltraps-中都需要保存所有寄存器吗？" class="headerlink" title="4. 对于任何中断，__alltraps 中都需要保存所有寄存器吗？"></a>4. <strong>对于任何中断，<code>__alltraps</code> 中都需要保存所有寄存器吗？</strong></h3><p><code>__alltraps</code> 需要保存所有寄存器。理由如下：</p><ul><li><strong>中断处理的不可预见性</strong>：在任何时间点中断都可能发生，而中断时可能会打断任何正在执行的代码。因此，在处理完中断后需要恢复到原来的状态，必须保存所有寄存器的状态以确保中断前的上下文能完全恢复。</li><li><strong>寄存器共享问题</strong>：在中断发生时，CPU 正在使用的寄存器（无论是通用寄存器、临时寄存器，还是参数寄存器）都可能被中断处理程序破坏。如果不保存所有寄存器，处理完中断后寄存器的状态可能已经被更改，导致被中断的程序出错。因此需要保存所有寄存器。</li><li><strong>统一处理</strong>：虽然某些情况下可能只需要保存部分寄存器，但为了简化设计，通常会统一保存所有寄存器，以保证在不同类型的中断或异常发生时，都能够正确地恢复执行。这样也减少了不同类型中断处理代码的复杂性。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>中断处理流程从中断发生、保存寄存器状态到处理完中断后恢复寄存器状态，涉及多个关键步骤。<code>mov a0, sp</code> 是为了传递栈指针给中断处理函数，而 <code>SAVE_ALL</code> 确保所有寄存器都被保存，以便恢复时能回到中断前的状态。</p><hr><h2 id="Challenge-2：理解上下文切换机制"><a href="#Challenge-2：理解上下文切换机制" class="headerlink" title="Challenge 2：理解上下文切换机制"></a>Challenge 2：理解上下文切换机制</h2><h3 id="csrw-sscratch-sp-和-csrrw-s0-sscratch-x0-的作用"><a href="#csrw-sscratch-sp-和-csrrw-s0-sscratch-x0-的作用" class="headerlink" title="csrw sscratch, sp 和 csrrw s0, sscratch, x0 的作用"></a>csrw sscratch, sp 和 csrrw s0, sscratch, x0 的作用</h3><ul><li><code>csrw sscratch, sp</code>：将当前栈指针 <code>sp</code> 的值保存到 <code>sscratch</code> CSR 中。</li><li><code>csrrw s0, sscratch, x0</code>：交换 <code>sscratch</code> 和 <code>s0</code> 的值。</li></ul><p>这两条指令的作用是保存当前的栈指针，并使用一个中间寄存器 <code>s0</code> 作为临时存储，以确保中断处理函数能够访问到当前的栈。</p><h3 id="保存了-stval-和-scause，但不还原的原因"><a href="#保存了-stval-和-scause，但不还原的原因" class="headerlink" title="保存了 stval 和 scause，但不还原的原因"></a>保存了 <code>stval</code> 和 <code>scause</code>，但不还原的原因</h3><p><code>stval</code> 和 <code>scause</code> 是异常和中断的状态寄存器，用于记录异常类型和发生的地址。保存它们是为了在中断处理过程中能够参考这些信息，但在恢复时不需要还原，因为它们的内容已经在处理中使用过，不影响恢复原有的执行状态。</p><hr><h2 id="Challenge-3：完善异常中断处理"><a href="#Challenge-3：完善异常中断处理" class="headerlink" title="Challenge 3：完善异常中断处理"></a>Challenge 3：完善异常中断处理</h2><p><img src="/image/report/1726980250503.png" alt="1726980250503"></p><p>增加了触发异常的代码，以及一些调试输出，以帮助确认异常处理流程是否正常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;clock.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;console.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;defs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;kdebug.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memlayout.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mmu.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;riscv.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;trap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sbi.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TICK_NUM 100</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">size_t</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">size_t</span> ticks = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">print_ticks</span><span class="hljs-params">()</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d ticks\n&quot;</span>, TICK_NUM);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG_GRADE</span><br>    cprintf(<span class="hljs-string">&quot;End of Test.\n&quot;</span>);<br>    panic(<span class="hljs-string">&quot;EOT: kernel seems ok.&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">idt_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> __alltraps(<span class="hljs-type">void</span>);<br>    write_csr(sscratch, <span class="hljs-number">0</span>);<br>    write_csr(stvec, &amp;__alltraps);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">trap_in_kernel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    <span class="hljs-keyword">return</span> (tf-&gt;status &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_trapframe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;trapframe at %p\n&quot;</span>, tf);<br>    print_regs(&amp;tf-&gt;gpr);<br>    cprintf(<span class="hljs-string">&quot;  status   0x%08x\n&quot;</span>, tf-&gt;status);<br>    cprintf(<span class="hljs-string">&quot;  epc      0x%08x\n&quot;</span>, tf-&gt;epc);<br>    cprintf(<span class="hljs-string">&quot;  badvaddr 0x%08x\n&quot;</span>, tf-&gt;badvaddr);<br>    cprintf(<span class="hljs-string">&quot;  cause    0x%08x\n&quot;</span>, tf-&gt;cause);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pushregs *gpr)</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;  zero     0x%08x\n&quot;</span>, gpr-&gt;zero);<br>    cprintf(<span class="hljs-string">&quot;  ra       0x%08x\n&quot;</span>, gpr-&gt;ra);<br>    cprintf(<span class="hljs-string">&quot;  sp       0x%08x\n&quot;</span>, gpr-&gt;sp);<br>    cprintf(<span class="hljs-string">&quot;  gp       0x%08x\n&quot;</span>, gpr-&gt;gp);<br>    cprintf(<span class="hljs-string">&quot;  tp       0x%08x\n&quot;</span>, gpr-&gt;tp);<br>    cprintf(<span class="hljs-string">&quot;  t0       0x%08x\n&quot;</span>, gpr-&gt;t0);<br>    cprintf(<span class="hljs-string">&quot;  t1       0x%08x\n&quot;</span>, gpr-&gt;t1);<br>    cprintf(<span class="hljs-string">&quot;  t2       0x%08x\n&quot;</span>, gpr-&gt;t2);<br>    cprintf(<span class="hljs-string">&quot;  s0       0x%08x\n&quot;</span>, gpr-&gt;s0);<br>    cprintf(<span class="hljs-string">&quot;  s1       0x%08x\n&quot;</span>, gpr-&gt;s1);<br>    cprintf(<span class="hljs-string">&quot;  a0       0x%08x\n&quot;</span>, gpr-&gt;a0);<br>    cprintf(<span class="hljs-string">&quot;  a1       0x%08x\n&quot;</span>, gpr-&gt;a1);<br>    cprintf(<span class="hljs-string">&quot;  a2       0x%08x\n&quot;</span>, gpr-&gt;a2);<br>    cprintf(<span class="hljs-string">&quot;  a3       0x%08x\n&quot;</span>, gpr-&gt;a3);<br>    cprintf(<span class="hljs-string">&quot;  a4       0x%08x\n&quot;</span>, gpr-&gt;a4);<br>    cprintf(<span class="hljs-string">&quot;  a5       0x%08x\n&quot;</span>, gpr-&gt;a5);<br>    cprintf(<span class="hljs-string">&quot;  a6       0x%08x\n&quot;</span>, gpr-&gt;a6);<br>    cprintf(<span class="hljs-string">&quot;  a7       0x%08x\n&quot;</span>, gpr-&gt;a7);<br>    cprintf(<span class="hljs-string">&quot;  s2       0x%08x\n&quot;</span>, gpr-&gt;s2);<br>    cprintf(<span class="hljs-string">&quot;  s3       0x%08x\n&quot;</span>, gpr-&gt;s3);<br>    cprintf(<span class="hljs-string">&quot;  s4       0x%08x\n&quot;</span>, gpr-&gt;s4);<br>    cprintf(<span class="hljs-string">&quot;  s5       0x%08x\n&quot;</span>, gpr-&gt;s5);<br>    cprintf(<span class="hljs-string">&quot;  s6       0x%08x\n&quot;</span>, gpr-&gt;s6);<br>    cprintf(<span class="hljs-string">&quot;  s7       0x%08x\n&quot;</span>, gpr-&gt;s7);<br>    cprintf(<span class="hljs-string">&quot;  s8       0x%08x\n&quot;</span>, gpr-&gt;s8);<br>    cprintf(<span class="hljs-string">&quot;  s9       0x%08x\n&quot;</span>, gpr-&gt;s9);<br>    cprintf(<span class="hljs-string">&quot;  s10      0x%08x\n&quot;</span>, gpr-&gt;s10);<br>    cprintf(<span class="hljs-string">&quot;  s11      0x%08x\n&quot;</span>, gpr-&gt;s11);<br>    cprintf(<span class="hljs-string">&quot;  t3       0x%08x\n&quot;</span>, gpr-&gt;t3);<br>    cprintf(<span class="hljs-string">&quot;  t4       0x%08x\n&quot;</span>, gpr-&gt;t4);<br>    cprintf(<span class="hljs-string">&quot;  t5       0x%08x\n&quot;</span>, gpr-&gt;t5);<br>    cprintf(<span class="hljs-string">&quot;  t6       0x%08x\n&quot;</span>, gpr-&gt;t6);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">interrupt_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    <span class="hljs-type">intptr_t</span> cause = (tf-&gt;cause &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span> (cause) &#123;<br>        <span class="hljs-keyword">case</span> IRQ_U_SOFT:<br>            cprintf(<span class="hljs-string">&quot;User software interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_S_SOFT:<br>            cprintf(<span class="hljs-string">&quot;Supervisor software interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_H_SOFT:<br>            cprintf(<span class="hljs-string">&quot;Hypervisor software interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_M_SOFT:<br>            cprintf(<span class="hljs-string">&quot;Machine software interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_U_TIMER:<br>            cprintf(<span class="hljs-string">&quot;User timer interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_S_TIMER:<br>            <span class="hljs-comment">/* LAB1 EXERCISE2: 时钟中断处理 */</span><br>            clock_set_next_event(); <span class="hljs-comment">// 设置下次时钟中断</span><br>            ticks++; <span class="hljs-comment">// 计数器加一</span><br>            <span class="hljs-keyword">if</span> (ticks % TICK_NUM == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 每 100 次中断时</span><br>                print_ticks(); <span class="hljs-comment">// 打印 &quot;100 ticks&quot;</span><br>                num++; <span class="hljs-comment">// 打印次数加一</span><br>                <span class="hljs-keyword">if</span> (num == <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 如果已打印 10 次</span><br>                    sbi_shutdown(); <span class="hljs-comment">// 调用 sbi_shutdown() 函数关机</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_H_TIMER:<br>            cprintf(<span class="hljs-string">&quot;Hypervisor timer interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_M_TIMER:<br>            cprintf(<span class="hljs-string">&quot;Machine timer interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_U_EXT:<br>            cprintf(<span class="hljs-string">&quot;User external interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_S_EXT:<br>            cprintf(<span class="hljs-string">&quot;Supervisor external interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_H_EXT:<br>            cprintf(<span class="hljs-string">&quot;Hypervisor external interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> IRQ_M_EXT:<br>            cprintf(<span class="hljs-string">&quot;Machine external interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            print_trapframe(tf);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exception_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (tf-&gt;cause) &#123;<br>        <span class="hljs-keyword">case</span> CAUSE_MISALIGNED_FETCH:<br>            cprintf(<span class="hljs-string">&quot;Misaligned fetch at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_FAULT_FETCH:<br>            cprintf(<span class="hljs-string">&quot;Fault fetch at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_ILLEGAL_INSTRUCTION:<br>            <span class="hljs-comment">/* LAB1 CHALLENGE3: 非法指令异常处理 */</span><br>            cprintf(<span class="hljs-string">&quot;Illegal instruction caught at 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            tf-&gt;epc += <span class="hljs-number">4</span>; <span class="hljs-comment">// 跳过非法指令</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_BREAKPOINT:<br>            <span class="hljs-comment">/* LAB1 CHALLENGE3: 断点异常处理 */</span><br>            cprintf(<span class="hljs-string">&quot;ebreak caught at 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            tf-&gt;epc += <span class="hljs-number">4</span>; <span class="hljs-comment">// 跳过断点指令</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_MISALIGNED_LOAD:<br>            cprintf(<span class="hljs-string">&quot;Misaligned load at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_FAULT_LOAD:<br>            cprintf(<span class="hljs-string">&quot;Fault load at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_MISALIGNED_STORE:<br>            cprintf(<span class="hljs-string">&quot;Misaligned store at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_FAULT_STORE:<br>            cprintf(<span class="hljs-string">&quot;Fault store at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_USER_ECALL:<br>            cprintf(<span class="hljs-string">&quot;User ecall at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_SUPERVISOR_ECALL:<br>            cprintf(<span class="hljs-string">&quot;Supervisor ecall at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_HYPERVISOR_ECALL:<br>            cprintf(<span class="hljs-string">&quot;Hypervisor ecall at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUSE_MACHINE_ECALL:<br>            cprintf(<span class="hljs-string">&quot;Machine ecall at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            cprintf(<span class="hljs-string">&quot;Unknown exception at address 0x%08x\n&quot;</span>, tf-&gt;epc);<br>            print_trapframe(tf);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">trap_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)tf-&gt;cause &lt; <span class="hljs-number">0</span>) &#123;<br>        interrupt_handler(tf);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        exception_handler(tf);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span> &#123;<br>    trap_dispatch(tf);<br>&#125;<br><br><span class="hljs-comment">//</span><br><br> 这里可以添加触发异常的代码示例<br><span class="hljs-type">void</span> <span class="hljs-title function_">trigger_exception</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;unimp&quot;</span>)</span>; <span class="hljs-comment">// 触发非法指令异常</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    idt_init();<br>    trigger_exception(); <span class="hljs-comment">// 测试触发异常的功能</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h3><ol><li><strong>异常处理</strong>：在 <code>exception_handler</code> 中，对非法指令异常进行了处理，并在捕获时输出相关信息。</li><li><strong>调试输出</strong>：增加了调试输出，可以帮助你确认代码流是否按照预期进行。</li><li><strong>触发异常的示例</strong>：<code>trigger_exception</code> 函数包含了触发非法指令的汇编代码，可以在 <code>main</code> 中调用以测试异常处理是否正常工作。</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="实验中的重要知识点："><a href="#实验中的重要知识点：" class="headerlink" title="实验中的重要知识点："></a>实验中的重要知识点：</h3><ul><li><strong>中断处理</strong>：处理不同类型的中断和异常，保证系统能够正常应对外部和内部事件。</li><li><strong>上下文切换</strong>：保存和恢复上下文是内核调度和中断处理中的关键操作。</li><li><strong>异常处理机制</strong>：正确捕获和处理非法指令及断点，是确保系统稳定性的重要环节。</li></ul><h3 id="OS原理中的重要知识点但实验中未涉及："><a href="#OS原理中的重要知识点但实验中未涉及：" class="headerlink" title="OS原理中的重要知识点但实验中未涉及："></a>OS原理中的重要知识点但实验中未涉及：</h3><ul><li><strong>进程调度算法</strong>：实验中没有深入实现进程的调度策略。</li><li><strong>内存管理机制</strong>：虽然涉及到栈指针的使用，但没有具体实现内存分配和页面管理。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OS2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ucore_lab0.5</title>
    <link href="/2024/09/22/ucore-lab0-5/"/>
    <url>/2024/09/22/ucore-lab0-5/</url>
    
    <content type="html"><![CDATA[<h1 id="lab0-5"><a href="#lab0-5" class="headerlink" title="lab0.5"></a>lab0.5</h1><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>实验0.5主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识。</p><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>实验0.5主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识,以及通过opensbi固件来通过服务。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>对实验报告的要求：</p><ul><li>基于markdown格式来完成，以文本方式为主</li><li>填写各个基本练习中要求完成的报告内容</li><li>列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）</li><li>列出你认为OS原理中很重要，但在实验中没有对应上的知识点</li></ul><p><img src="/image/report/1726140755541.png" alt="1726140755541"></p><p><strong>打开 GDB</strong>：</p><ol><li><ul><li><p>打开另一个终端并启动 GDB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make gdb<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>调试流程</strong>：</p><ul><li><p><strong>查看加电后指令</strong>：<br>使用 <code>x/10i</code> 指令查看加电后位于 <code>0x80000000</code> 地址的 10 条汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) x/10i 0x80000000<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207417372.png" alt="1726207417372"></p></li><li><p><strong>查看当前指令</strong>：<br>使用 <code>x/10i $pc</code> 指令查看即将执行的 10 条汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) x/10i $pc<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207437063.png" alt="1726207437063"></p></li><li><p><strong>查看数据</strong>：<br>使用 <code>x/10xw</code> 指令查看 <code>0x80000000</code> 处的 10 个 32 位数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) x/10xw 0x80000000<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207537395.png" alt="1726207537395"></p></li><li><p><strong>查看寄存器信息</strong>：<br>使用 <code>info register</code> 指令查看当前所有寄存器的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) info register<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207561226.png" alt="1726207561226"></p></li><li><p><strong>设置断点</strong>：<br>设置断点在 <code>0x80200000</code> 地址处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) break *0x80200000<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207704915.png" alt="1726207704915"></p></li><li><p><strong>继续执行</strong>：<br>使用 <code>continue</code> 指令运行程序，直到遇到断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) continue<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207756827.png" alt="1726207756827"></p></li><li><p><strong>单步执行</strong>：<br>使用 <code>si</code> 指令单步执行一条汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gdb">(gdb) si<br></code></pre></td></tr></table></figure><p><img src="/image/report/1726207772133.png" alt="1726207772133"></p></li></ul></li><li><p><strong>加电后的 RISC-V 指令及功能</strong>：</p><ul><li>加电后的几条指令通常是初始化指令，包括设置堆栈指针、初始化全局数据和调用启动例程。</li><li>示例指令可能包括初始化 <code>t0</code> 寄存器的值、设置程序计数器（PC）指向主程序等。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OS2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLVM</title>
    <link href="/2024/09/10/LLVM/"/>
    <url>/2024/09/10/LLVM/</url>
    
    <content type="html"><![CDATA[<h2 id="了解编译器"><a href="#了解编译器" class="headerlink" title="了解编译器"></a>了解编译器</h2><h3 id="1-预处理阶段"><a href="#1-预处理阶段" class="headerlink" title="1. 预处理阶段"></a>1. <strong>预处理阶段</strong></h3><p>   运行以下命令生成预处理后的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E mul.c -o mul.i<br></code></pre></td></tr></table></figure><ul><li><strong>输出文件</strong>：<code>mul.i</code></li><li><strong>说明</strong>：此文件包含了宏展开和头文件包含后的源代码。可以打开这个文件，观察 <code>#include &lt;iostream&gt;</code>是如何被展开的。</li></ul><h3 id="2-编译阶段（生成汇编代码）"><a href="#2-编译阶段（生成汇编代码）" class="headerlink" title="2. 编译阶段（生成汇编代码）"></a>2. <strong>编译阶段（生成汇编代码）</strong></h3><p>   运行以下命令生成汇编代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -S mul.i -o mul.s<br></code></pre></td></tr></table></figure><ul><li><strong>输出文件</strong>：<code>mul.s</code></li><li><strong>说明</strong>：这个文件是由源代码生成的汇编代码，可以打开此文件，查看C++代码如何被翻译成汇编指令。</li></ul><h3 id="3-汇编阶段（生成目标文件）"><a href="#3-汇编阶段（生成目标文件）" class="headerlink" title="3. 汇编阶段（生成目标文件）"></a>3. <strong>汇编阶段（生成目标文件）</strong></h3><p>   运行以下命令将汇编代码转换为目标文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c mul.s -o mul.o<br></code></pre></td></tr></table></figure><ul><li><strong>输出文件</strong>：<code>mul.o</code></li><li><strong>说明</strong>：此文件是机器码，无法直接阅读。它会在链接时使用。</li></ul><h3 id="4-链接阶段（生成可执行文件）"><a href="#4-链接阶段（生成可执行文件）" class="headerlink" title="4. 链接阶段（生成可执行文件）"></a>4. <strong>链接阶段（生成可执行文件）</strong></h3><p>   最后，运行以下命令生成最终的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc mul.o -o mul<br></code></pre></td></tr></table></figure><ul><li><strong>输出文件</strong>：<code>mul</code>（在Windows上可能是 <code>mul.exe</code>）</li><li><strong>说明</strong>：此可执行文件包含了所有库和外部引用，现在可以运行这个程序。</li></ul><h3 id="5-运行程序"><a href="#5-运行程序" class="headerlink" title="5. 运行程序"></a>5. <strong>运行程序</strong></h3><p>   使用以下命令运行程序并输入一个数来测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./mul<br></code></pre></td></tr></table></figure><p>   输入一个整数，程序将输出对应的阶乘。</p><h3 id="6-使用LLVM工具链"><a href="#6-使用LLVM工具链" class="headerlink" title="6. 使用LLVM工具链"></a>6. <strong>使用LLVM工具链</strong></h3><p>   如果你使用的是LLVM&#x2F;Clang工具链，步骤类似：</p><ul><li><p><strong>预处理</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -E mul.c -o mul.i<br></code></pre></td></tr></table></figure></li><li><p><strong>编译（生成LLVM IR）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -emit-llvm -S mul.c -o mul.ll<br></code></pre></td></tr></table></figure><p>这将生成LLVM的中间表示。</p></li><li><p><strong>编译（生成汇编代码）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -S mul.ll -o mul.s<br></code></pre></td></tr></table></figure></li><li><p><strong>汇编</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -c mul.s -o mul.o<br></code></pre></td></tr></table></figure></li><li><p><strong>链接并生成可执行文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang mul.o -o mul<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>通过这几个步骤，可以看到每个阶段生成的文件，并观察编译器如何处理源代码。</li></ul><h2 id="不同阶段生成的文件"><a href="#不同阶段生成的文件" class="headerlink" title="不同阶段生成的文件"></a>不同阶段生成的文件</h2><p>问题描述了从汇编生成目标文件、链接生成可执行文件的过程。具体而言，目标文件不能直接执行，必须与其他目标文件或库链接，生成最终的可执行文件。链接器的作用是将这些机器代码结合起来，处理外部引用，分配地址空间，最终生成可执行的二进制文件。</p><p>你可以通过以下步骤探索这个流程，并查看不同阶段生成的文件之间的差异：</p><h3 id="1-编译源文件生成目标文件"><a href="#1-编译源文件生成目标文件" class="headerlink" title="1. 编译源文件生成目标文件"></a>1. 编译源文件生成目标文件</h3><p>使用 <code>gcc</code> 编译源文件生成目标文件（<code>.o</code> 文件）。目标文件是可重定位的机器代码，不能独立运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c main.c -o main.o<br></code></pre></td></tr></table></figure><h3 id="2-链接目标文件生成可执行文件"><a href="#2-链接目标文件生成可执行文件" class="headerlink" title="2. 链接目标文件生成可执行文件"></a>2. 链接目标文件生成可执行文件</h3><p>使用链接器将目标文件链接为可执行文件。你可以选择静态链接或动态链接：</p><ul><li><p><strong>静态链接</strong>：<br>静态链接意味着所有库的代码都会被复制到最终的可执行文件中，生成的可执行文件体积较大，但可以独立运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -static main.o -o main<br></code></pre></td></tr></table></figure></li><li><p><strong>动态链接</strong>：<br>动态链接则是将库的引用保留在最终的可执行文件中，运行时需要操作系统提供相应的动态链接库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc main.o -o main<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-反汇编可执行文件"><a href="#3-反汇编可执行文件" class="headerlink" title="3. 反汇编可执行文件"></a>3. 反汇编可执行文件</h3><p>可以使用 <code>objdump</code> 或其他反汇编工具来查看生成的目标文件或可执行文件的汇编代码，比较不同阶段的差异。</p><ul><li><p><strong>反汇编目标文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d main.o<br></code></pre></td></tr></table></figure></li><li><p><strong>反汇编可执行文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d main<br></code></pre></td></tr></table></figure></li></ul><p>在链接后，你可以观察到以下几点差异：</p><ul><li>可执行文件中的地址通常是绝对的，而目标文件中的地址是相对的（因为链接器会负责地址分配）。</li><li>外部函数调用在可执行文件中已经被解析为真实的地址，而在目标文件中仍是未解析的符号。</li></ul><h3 id="4-加载和执行"><a href="#4-加载和执行" class="headerlink" title="4. 加载和执行"></a>4. 加载和执行</h3><p>执行可执行文件时，操作系统的加载器会将可执行文件的内容载入内存，设置必要的内存布局，初始化堆栈和堆，并将程序的控制权交给入口点。这部分过程是由操作系统和硬件管理的，超出了编译和链接的范围。</p><hr><p><strong>总结</strong>：</p><ul><li>编译生成的目标文件不能直接执行，必须通过链接器与其他文件和库结合，生成最终的可执行文件。</li><li>反汇编目标文件和可执行文件可以看到链接后的地址分配和符号解析的不同。</li><li>你可以通过调整链接选项（如 <code>-static</code>）来改变可执行文件的生成方式，从而影响反汇编后的结构。</li></ul><p><code>llvm-dis</code> 是 LLVM 的反汇编工具，主要用于将 LLVM 的二进制位码（bitcode）文件 <code>.bc</code> 转换为人类可读的 LLVM IR（<code>.ll</code> 文件）。出现 <code>file doesn&#39;t start with bitcode header</code> 错误的原因是你尝试将 <code>.ll</code> 文件（文本格式）转换为 <code>.bc</code> 文件（位码格式），但它并非位码文件，因此 <code>llvm-dis</code> 无法解析。</p><p>正确的步骤应该是：</p><ol><li><p><strong>生成 <code>.ll</code> 文件</strong>：通过使用 <code>clang</code> 或 <code>gcc</code> 编译你的 C 文件为 LLVM IR 代码。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -S -emit-llvm mul.c -o mul.ll<br></code></pre></td></tr></table></figure></li><li><p><strong>将 <code>.ll</code> 文件编译为 <code>.bc</code> 文件</strong>：如果你有一个 <code>.ll</code> 文件，并且想将其转换为位码 <code>.bc</code> 文件，你应该使用 <code>llvm-as</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-as mul.ll -o mul.bc<br></code></pre></td></tr></table></figure></li><li><p><strong>将 <code>.bc</code> 文件反汇编为 <code>.ll</code> 文件</strong>：在拥有 <code>.bc</code> 位码文件之后，可以使用 <code>llvm-dis</code> 将其反汇编回 <code>.ll</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-dis mul.bc -o mul.ll<br></code></pre></td></tr></table></figure></li></ol><h3 id="解决方案步骤："><a href="#解决方案步骤：" class="headerlink" title="解决方案步骤："></a>解决方案步骤：</h3><ol><li><p><strong>首先确保生成 <code>.ll</code> 文件</strong>：</p><ul><li>使用 <code>clang</code> 生成 LLVM IR 代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -S -emit-llvm mul.c -o mul.ll<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>然后生成 <code>.bc</code> 文件</strong>：</p><ul><li>使用 <code>llvm-as</code> 将 <code>.ll</code> 文件转换为 <code>.bc</code> 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-as mul.ll -o mul.bc<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>验证生成的 <code>.bc</code> 文件</strong>：</p><ul><li>通过 <code>llvm-dis</code> 命令可以反汇编 <code>.bc</code> 文件，验证内容是否正确：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-dis mul.bc -o mul.ll<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些步骤，你应该能够正确地生成并处理 <code>.bc</code> 和 <code>.ll</code> 文件。</p><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><p>要执行 <code>Makefile</code> 文件，首先确保以下几点：</p><ol><li>确保已经创建了一个名为 <code>Makefile</code> 或者 <code>makefile</code> 的文件，并将你写好的内容保存进去。</li><li>确保 <code>main.c</code> 文件存在，并且路径正确。</li></ol><p>执行步骤如下：</p><ol><li><p><strong>进入包含 <code>Makefile</code> 和 <code>main.c</code> 的目录</strong>：</p><p>打开终端，并使用 <code>cd</code> 命令进入包含 <code>Makefile</code> 和 <code>main.c</code> 的目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mnt/d/2024fall/编译/lab/lab1/CompilingProject/lab1/your_project<br></code></pre></td></tr></table></figure></li><li><p><strong>执行 <code>make</code> 命令</strong>：</p><p>执行 <code>make</code> 命令时，可以指定你想执行的目标。比如，如果你想执行 <code>pre</code> 目标，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make pre<br></code></pre></td></tr></table></figure><p>如果想执行词法分析 <code>lexer</code> 目标，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make lexer<br></code></pre></td></tr></table></figure></li><li><p><strong>执行全部默认目标</strong>：</p><p>如果没有指定任何目标，<code>make</code> 会执行 <code>Makefile</code> 中的第一个目标。你可以通过以下命令执行默认的目标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure></li><li><p><strong>清理生成的文件</strong>：</p><p>要清除生成的文件，运行 <code>clean</code> 目标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean<br></code></pre></td></tr></table></figure><p>如果你想清除所有生成的文件，运行 <code>clean-all</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean-all<br></code></pre></td></tr></table></figure></li></ol><p>通过这些步骤，可以按需要执行不同的编译和分析阶段。</p><h2 id="要实现一个SysY编译器并通过LLVM-IR生成目标程序"><a href="#要实现一个SysY编译器并通过LLVM-IR生成目标程序" class="headerlink" title="要实现一个SysY编译器并通过LLVM IR生成目标程序"></a>要实现一个SysY编译器并通过LLVM IR生成目标程序</h2><h3 id="1-编写SysY源程序"><a href="#1-编写SysY源程序" class="headerlink" title="1. 编写SysY源程序"></a>1. 编写SysY源程序</h3><p>假设你选择的是一个简单的阶乘程序，SysY 是 C 的子集，所以可以用以下形式编写这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> fact(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序是递归求阶乘的函数，SysY 语法和 C 语法几乎一样，所以我们可以将其转化为 LLVM IR 进行编译。</p><h3 id="2-使用LLVM-Clang生成LLVM-IR"><a href="#2-使用LLVM-Clang生成LLVM-IR" class="headerlink" title="2. 使用LLVM&#x2F;Clang生成LLVM IR"></a>2. 使用LLVM&#x2F;Clang生成LLVM IR</h3><h4 id="编写LLVM-IR代码："><a href="#编写LLVM-IR代码：" class="headerlink" title="编写LLVM IR代码："></a>编写LLVM IR代码：</h4><p>根据你提供的SysY程序，我们可以手动编写一个等效的LLVM IR代码，当然这只是一个手工写例子，实际编译器会通过前端生成：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-comment">; 函数声明</span><br><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@fact</span>(<span class="hljs-type">i32</span> <span class="hljs-variable">%n</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>    <span class="hljs-comment">; 判断 n 是否为 0</span><br>    <span class="hljs-variable">%cmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">eq</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%n</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%cmp</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%if.then</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%if.else</span><br><br>if.then:                                       <br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-number">1</span><br><br>if.else:                                       <br>    <span class="hljs-comment">; 递归调用 fact(n - 1)</span><br>    <span class="hljs-variable">%n_sub_1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">sub</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%n</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><br>    <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i32</span> <span class="hljs-title">@fact</span>(<span class="hljs-type">i32</span> <span class="hljs-variable">%n_sub_1</span>)<br>    <span class="hljs-comment">; 返回 n * fact(n - 1)</span><br>    <span class="hljs-variable">%mul</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%n</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%call</span><br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%mul</span><br>&#125;<br><br><span class="hljs-comment">; 主函数</span><br><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@main</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>    <span class="hljs-comment">; 调用 fact(5)</span><br>    <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i32</span> <span class="hljs-title">@fact</span>(<span class="hljs-type">i32</span> <span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%call</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成LLVM-IR文件："><a href="#生成LLVM-IR文件：" class="headerlink" title="生成LLVM IR文件："></a>生成LLVM IR文件：</h4><p>你可以通过命令行工具 <code>clang</code> 来生成 LLVM IR。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -S -emit-llvm fact.c -o fact.ll<br></code></pre></td></tr></table></figure><p>这个命令会将你的SysY程序编译成LLVM IR，输出到 <code>fact.ll</code> 文件中。</p><h3 id="3-编译LLVM-IR生成目标代码"><a href="#3-编译LLVM-IR生成目标代码" class="headerlink" title="3. 编译LLVM IR生成目标代码"></a>3. 编译LLVM IR生成目标代码</h3><p>现在你已经有了LLVM IR文件，可以将其编译成目标程序。你可以使用 <code>llc</code> 命令将LLVM IR转化为汇编代码，接着使用 <code>gcc</code> 链接生成可执行文件。</p><h4 id="使用-llc生成汇编代码："><a href="#使用-llc生成汇编代码：" class="headerlink" title="使用 llc生成汇编代码："></a>使用 <code>llc</code>生成汇编代码：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llc fact.ll -o fact.s<br></code></pre></td></tr></table></figure><p>这会生成对应的汇编代码 <code>fact.s</code>。</p><h4 id="使用-gcc-生成可执行文件："><a href="#使用-gcc-生成可执行文件：" class="headerlink" title="使用 gcc 生成可执行文件："></a>使用 <code>gcc</code> 生成可执行文件：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc fact.s -o fact<br></code></pre></td></tr></table></figure><p>这样，你的LLVM IR就被编译成了可执行的目标程序。</p><h3 id="4-验证结果"><a href="#4-验证结果" class="headerlink" title="4. 验证结果"></a>4. 验证结果</h3><p>现在，你可以运行生成的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./fact<br></code></pre></td></tr></table></figure><p>这个程序会返回 <code>120</code>，因为 <code>5! = 120</code>。</p><h3 id="5-查看各阶段的输出"><a href="#5-查看各阶段的输出" class="headerlink" title="5. 查看各阶段的输出"></a>5. 查看各阶段的输出</h3><p>在生成LLVM IR文件和汇编代码的过程中，你可以通过命令行选项获得各个阶段的输出，并分析它们和源代码的关系。</p><p>例如：</p><h4 id="查看LLVM-IR："><a href="#查看LLVM-IR：" class="headerlink" title="查看LLVM IR："></a>查看LLVM IR：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -S -emit-llvm fact.c -o fact.ll<br><span class="hljs-built_in">cat</span> fact.ll<br></code></pre></td></tr></table></figure><h4 id="查看汇编代码："><a href="#查看汇编代码：" class="headerlink" title="查看汇编代码："></a>查看汇编代码：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">llc fact.ll -o fact.s<br><span class="hljs-built_in">cat</span> fact.s<br></code></pre></td></tr></table></figure><h4 id="反汇编："><a href="#反汇编：" class="headerlink" title="反汇编："></a>反汇编：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d fact<br></code></pre></td></tr></table></figure><h4 id="查看符号表："><a href="#查看符号表：" class="headerlink" title="查看符号表："></a>查看符号表：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nm fact<br></code></pre></td></tr></table></figure><p>通过这些命令，你可以获得不同阶段的输出，并分析它们如何从源程序演变到目标程序的过程。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>你可以通过 <code>clang</code> 将SysY程序编译成LLVM IR，利用LLVM工具链生成汇编代码和可执行文件。通过研究LLVM IR和各个编译阶段的输出，你可以更好地理解SysY编译器的实现。</p>]]></content>
    
    
    <categories>
      
      <category>complie</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2024fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello</title>
    <link href="/2024/08/30/hello-world/"/>
    <url>/2024/08/30/hello-world/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-serverhexo-generate"><a href="#Run-serverhexo-generate" class="headerlink" title="Run serverhexo generate"></a>Run serverhexo generate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>just test a test</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p>在 markdown 中加入如下的代码来使用 Label：</p>            <input type="checkbox"  checked="checked">text          <ul><li>text：显示的文字</li><li>checked：默认是否已勾选，默认 false</li><li>incline: 是否内联（可以理解为后面的文字是否换行），默认 false</li></ul><a class="btn" href="url"  title="title" target="_blank">text</a><p><a class="btn" href="url" title="title">text</a></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
